"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.SharedTypeMap = exports.NodeTypeMap = exports.EdgeTypeMap = void 0;
function _assert() {
  const data = _interopRequireDefault(require("assert"));
  _assert = function () {
    return data;
  };
  return data;
}
function _nullthrows() {
  const data = _interopRequireDefault(require("nullthrows"));
  _nullthrows = function () {
    return data;
  };
  return data;
}
var _sharedBuffer = require("./shared-buffer");
var _types = require("./types");
var _Graph = require("./Graph");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/** The address of the node in the nodes map. */
/** The address of the edge in the edges map. */
// eslint-disable-next-line no-unused-vars
// eslint-disable-next-line no-unused-vars
const DEFAULT_PARAMS = {
  initialCapacity: 2,
  unloadFactor: 0.3,
  maxGrowFactor: 8,
  minGrowFactor: 2,
  peakCapacity: 2 ** 18,
  shrinkFactor: 0.5
};

/**
 * An Enum representing the result of a call to `link`.
 *
 * `EdgeAdded`       = `0`: the edge was successfully linked
 * `EdgeExists`      = `1`: the edge already exists
 * `EdgesOverloaded` = `2`: the edge map is overloaded
 * `TooManyDeletes`  = `3`: the edge map has too many deleted edges
 * `NodesOverloaded` = `4`: the node map is overloaded
 */
const LinkResult = {
  EdgeAdded: 0,
  EdgeExists: 1,
  EdgesOverloaded: 2,
  TooManyDeletes: 3,
  NodesOverloaded: 4
};

/**
 * Allow 3 attempts to link an edge before erroring.
 *
 * The three attempts correspond to the three possible inconclusive link results:
 * - `LinkResult.EdgesOverloaded`
 * - `LinkResult.TooManyDeletes`
 * - `LinkResult.NodesOverloaded`
 *
 * If after 3 tries, the link result is still one of these,
 * this is considered an error.
 */
const MAX_LINK_TRIES = 3;

/**
 * `AdjacencyList` maps nodes to lists of their adjacent nodes.
 *
 * It is implemented as a hashmap of nodes, where each node has
 * doubly linked lists of edges of each unique edge type.
 * The edges are stored in a separate hashmap, where each edge has
 * a pointer to the originating node, the terminating node, and
 * the next and previous edges to and from adjacent nodes.
 *
 * The hash maps are each stored in a `Uint32Array` backed
 * by a `SharedArrayBuffer`. See `SharedTypeMap` for more details.
 *
 * It's primary interface is through the `getNodeIdsConnectedFrom`
 * and `getNodeIdsConnectedTo` methods, which return the list of
 * nodes connected from or to a given node, respectively.
 *
 * It is also possible to get the lists of edges connected from or to
 * a given node, using the `getOutboundEdgesByType` and
 * `getInboundEdgesByType` methods.
 *
 */
class AdjacencyList {
  #nodes /*: NodeTypeMap<TEdgeType | NullEdgeType> */;
  #edges /*: EdgeTypeMap<TEdgeType | NullEdgeType> */;

  #params /*: AdjacencyListParams */;

  /**
   * Create a new `AdjacencyList` in one of two ways:
   * - with specified options, or
   * - with data serialized from a previous `AdjacencyList`.
   */
  constructor(opts) {
    let nodes;
    let edges;
    if (opts !== null && opts !== void 0 && opts.nodes) {
      ({
        nodes,
        edges
      } = opts);
      this.#nodes = new NodeTypeMap(nodes);
      this.#edges = new EdgeTypeMap(edges);
      this.#params = {
        ...DEFAULT_PARAMS,
        initialCapacity: this.#edges.capacity
      };
    } else {
      this.#params = {
        ...DEFAULT_PARAMS,
        ...opts
      };
      let {
        initialCapacity
      } = this.#params;

      // TODO: Find a heuristic for right-sizing nodes.
      // e.g., given an average ratio of `e` edges for every `n` nodes,
      // init nodes with `capacity * n / e`.
      let initialNodeCapacity = 2;
      NodeTypeMap.assertMaxCapacity(initialNodeCapacity);
      EdgeTypeMap.assertMaxCapacity(initialCapacity);
      this.#nodes = new NodeTypeMap(initialNodeCapacity);
      this.#edges = new EdgeTypeMap(initialCapacity);
    }
  }

  /**
   * Create a new `AdjacencyList` with data serialized
   * from another `AdjacencyList`.
   */
  static deserialize(opts) {
    return new AdjacencyList(opts);
  }

  /**
   * Returns a serializable object of the nodes and edges in the AdjacencyList.
   */
  serialize() {
    return {
      nodes: this.#nodes.data,
      edges: this.#edges.data
    };
  }

  /** Statistics about the current state of the `AdjacencyList`. */
  get stats() {
    let edgeTypes = new Set();
    let buckets = new Map();
    for (let {
      from,
      to,
      type
    } of this.getAllEdges()) {
      let hash = this.#edges.hash(from, to, type);
      let bucket = buckets.get(hash) || new Set();
      let key = `${String(from)}, ${String(to)}, ${String(type)}`;
      (0, _assert().default)(!bucket.has(key), `Duplicate node detected: ${key}`);
      bucket.add(key);
      buckets.set(hash, bucket);
      edgeTypes.add(type);
    }
    let maxCollisions = 0;
    let collisions = 0;
    let distribution = 0;
    /**
     * The expected distribution of hashes across available hash buckets.
     *
     * See: https://en.wikipedia.org/wiki/Hash_function#Testing_and_measurement
     */
    let uniformDistribution = this.#edges.count / (2 * this.#edges.capacity) * (this.#edges.count + 2 * this.#edges.capacity - 1);
    for (let bucket of buckets.values()) {
      maxCollisions = Math.max(maxCollisions, bucket.size - 1);
      collisions += bucket.size - 1;
      distribution += bucket.size * (bucket.size + 1) / 2;
    }
    return {
      capacity: this.#edges.capacity,
      nodes: (0, _types.fromNodeId)(this.#nodes.nextId),
      nodeEdgeTypes: this.#nodes.count,
      nodeLoad: `${Math.round(this.#nodes.load * 100)}%`,
      nodeBufferSize: this.#nodes.bufferSize,
      edges: this.#edges.count,
      deleted: this.#edges.deletes,
      edgeTypes: edgeTypes.size,
      edgeLoad: `${Math.round(this.#edges.load * 100)}%`,
      edgeLoadWithDeletes: `${Math.round(this.#edges.getLoad(this.#edges.count + this.#edges.deletes) * 100)}%`,
      edgeBufferSize: this.#edges.bufferSize,
      collisions,
      maxCollisions,
      avgCollisions: Math.round(collisions / this.#edges.count * 100) / 100 || 0,
      uniformity: Math.round(distribution / uniformDistribution * 100) / 100 || 0
    };
  }

  /**
   * Resize the internal nodes array.
   *
   * This is used in `addNode` and in `addEdge` when
   * the `nodes` array is at capacity,
   */
  resizeNodes(size) {
    let nodes = this.#nodes;
    // Allocate the required space for a `nodes` map of the given `size`.
    this.#nodes = new NodeTypeMap(size);
    // Copy the existing nodes into the new array.
    this.#nodes.set(nodes.data);
  }

  /**
   * Resize the internal edges array.
   *
   * This is used in `addEdge` when the `edges` array is at capacity.
   */
  resizeEdges(size) {
    // Allocate the required space for new `nodes` and `edges` maps.
    let edges = new EdgeTypeMap(size);
    let nodes = new NodeTypeMap(this.#nodes.capacity);

    // Copy the existing edges into the new array.
    nodes.nextId = this.#nodes.nextId;
    this.#edges.forEach(edge => void link(this.#edges.from(edge), this.#edges.to(edge), this.#edges.typeOf(edge), edges, nodes, this.#params.unloadFactor));

    // We expect to preserve the same number of edges.
    (0, _assert().default)(this.#edges.count === edges.count, `Edge mismatch! ${this.#edges.count} does not match ${edges.count}.`);

    // Finally, copy the new data arrays over to this graph.
    this.#nodes = nodes;
    this.#edges = edges;
  }

  /**
   * Adds a node to the graph.
   *
   * Note that this method does not increment the node count
   * (that only happens in `addEdge`), it _may_ preemptively resize
   * the nodes array if it is at capacity, under the asumption that
   * at least 1 edge to or from this new node will be added.
   *
   * Returns the id of the added node.
   */
  addNode() {
    let id = this.#nodes.getId();
    if (this.#nodes.getLoad() >= 1) {
      this.resizeNodes(increaseNodeCapacity(this.#nodes.capacity, this.#params));
    }
    return id;
  }

  /**
   * Adds an edge to the graph.
   *
   * This method will increment the edge 